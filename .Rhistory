bar_v = 0
bar_beta = 0
fit = 0
all_fits = data.frame()
all_MSE = data.frame()
}
all_BIC = data.frame()
accept_count = 0
#setting up counters for final Metropolis-Hasting
type = "0"
a.count <<- 0
s.count <<- 0
m.count <<- 0
j.count <<- 0
add.accept.count <<- 0
sub.accept.count <<- 0
move.accept.count <<- 0
jiggle.accept.count <<- 0
#getting constants for qs for final Metropolis-Hasting
starting_bkpts = length(k_ends) - 1 #most probable number of breakpoints based on starting info
starting_nfree = length(freeObservations(k_ends,ma))
burn_in = 50
make_murder_p = 0.5
percent = 0.02
lambda = 1
tao = abs(1)
bs(1), alpha = 0, mu = 1.5, jump_p = 0.25, ma = 1, progress = TRUE, fit_storage = TRUE)
jump_p = 0.25
ma = 1
mu = 1.5,
mu = 1.5
alpha = 0
fit_storage = TRUE
progress = TRUE
burn_in = 50
make_murder_p = 0.5
lambda = 1
percent = 0.02
y = rnorm(1,0,1)
mu = 1
alpha = .5
epsilon = c(rnorm(1,0,1))
epsilon = function(t){ # t MUST be greater than or equal to 2
for (i in 2:t){
epsilon[i-1] = rnorm(1,0,1)
}
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon(2) # + .............
}
y[i]= mu + epsilon[1] + alpha*epsilon(2) # + .............
epsilon[1]
epsilon = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 2:t){
epsilon_t[i-1] = rnorm(1,0,1)
}
}
y[i]= mu + epsilon + alpha*epsilon(2) # + .............
epsilon = rnorm(1,0,1)
y[i]= mu + epsilon + alpha*epsilon(2)
epsilon = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 2:t){
epsilon_t[i-1] = rnorm(1,0,1)
}
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon(2) # + .............
}
epsilon = rnorm(1,0,1)
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon(2) # + .............
}
epsilon = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 2:t){
epsilon_t[i-1] = rnorm(1,0,1)
}
}
mu = 1
y = rnorm(1,0,1)
alpha = .5
epsilon = rnorm(1,0,1)
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon(2) # + .............
}
mu = 1
y = rnorm(1,0,1)
alpha = .5
epsilon = rnorm(1,0,1)
epsilon_t = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 2:t){
epsilon_t[i-1] = rnorm(1,0,1)
}
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
mu = 1
y = rnorm(1,0,1)
alpha = .5
epsilon = rnorm(1,0,1)
epsilon_t = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 1:t){
epsilon_t[i] = rnorm(1,0,1)
}
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
mu = 1
y = rnorm(1,0,1)
alpha = .5
epsilon = rnorm(1,0,1)
for (i in 1:t){
epsilon_t[i] = rnorm(1,0,1)
}
epsilon_t = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 1:t){
epsilon_t[i] = rnorm(1,0,1)
}
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
epsilon_t(2)
epsilon_t(2)
mu
epsilon
alpha
epsilon_t = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 1:t){
epsilon_t[i] = rnorm(1,0,1)
}
return(epsilon_t[t])
}
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
epsilon_t[i] = rnorm(1,0,1)
epsilon_t = function(t){ # t MUST be greater than or equal to 2
epsilon_t = c(epsilon)
for (i in 1:t){
epsilon_t[i] = rnorm(1,0,1)
}
return(epsilon_t[t])
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
for (i in 1:90){
y[i]= mu + epsilon + alpha*epsilon_t(2) # + .............
}
library(devtools)
#install_version("FitAR", version = "1.94", repos = "http://cran.us.r-project.org")
#library(FitAR)
library(forecast)
library(strucchange)
library(stats)
library(MASS)
par(mar=c(1,1,1,1))
setwd("/Users/mellm/github/REU2022/test_Cases")
suicide<-read.csv("suicideRatesData.csv")
attach(suicide)
setwd("/Users/mellm/github/REU2022/")
source("ar_bai_perron.r")
source("data_for_trials.r")
source("Variations_of_bars/fixedbaar1.r")
#fit data with ARIMA
single_model <- arima(suicide$X15.24.years, order=c(2,0,0))
single_fitted <- fitted(single_model)
test_data_45 = function(){
data_45=suicide$X15.24.years
time = c(1:37)
test_data_45 = data.frame(time, data_45)
return(test_data_45)
}
iterations=1000
runs=10
L=matrix(NA,nrow=iterations,ncol=runs)
A=NA
M=NA
B=NA
for(i in 1:runs){
current_data = test_data_45()
break_p = breakpoints(current_data[,2] ~ current_data[,1], breaks = 3, h = 0.1)
starting_breakpoints = break_p$breakpoints
test1=baar(starting_breakpoints,1:37,current_data[,2],iterations, 15, jump=0.25, ar=3)
print(i)
L[,i]=test1$NumBkpts
M[i]=length(starting_breakpoints[!is.na(starting_breakpoints)])
A=c(A,(unlist(test1$Breakpoints))) #Baar location of breakpoints
B=c(B,(starting_breakpoints)) #B-P
}
A2=A[!is.na(A)]
B2=B[!is.na(B)]
mean(L)
sd(L)
mean(M)
sd(M)
current_data = ts(current_data)
current_data = test_data_45()
A3 = unique(A2)
A3 = sort(unique(A2))
A3[1]
ncol(current_data)
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  c() #list of arima'ed time series
new_time = c() #list of time vectors for each bkpt (for spliced_data)
new_data = c() #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
new_time[i] = c(current_data[,j][1:i])
} else if (j == 2){ #if j is data_45
new_data[i] = c(current_data[,j][1:i])
}
}
}
spliced_data(current_data)
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_data[i],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
}
return(unique(new_fits))
}
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
new_start = data.frame(new_time,new_data)
new_time = c() #list of time vectors for each bkpt (for spliced_data)
new_data = c() #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
View(new_start)
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
new_start$new_data[[1]]
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_start$new_data[[i]],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  c() #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
new_time[i] = c(current_data[,j][1:i])
} else if (j == 2){ #if j is data_45
new_data[i] = c(current_data[,j][1:i])
}
}
}
spliced_data(current_data)
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_start$new_data[[i]],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
}
return(unique(new_fits))
}
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
current_data[,2][1:15]
current_data[,2][1:1]
new_start$new_data[[1]]
spliced_fitted_arima =  NA #list of arima'ed time series
new_fits = c() #list of new fitted values
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  NA #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
new_time[i] = c(current_data[,j][1:i])
} else if (j == 2){ #if j is data_45
new_data[i] = c(current_data[,j][1:i])
}
}
}
spliced_data(current_data)
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_start$new_data[[i]],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
}
return(unique(new_fits))
}
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
NCOL(current_data)
new_start = data.frame(new_time,new_data)
ncol(new_start)
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  NA #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
append(new_time,c(current_data[,j][1:i]))
} else (j==2){
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  NA #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
append(new_time,c(current_data[,j][1:i]))
} else (j==2) {
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
append(new_time,c(current_data[,j][1:i]))
} else (j==2) {
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  NA #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
append(new_time,c(current_data[,j][1:i]))
} else if (j==2) {
append(new_data,c(current_data[,j][1:i]))
}
}
}
spliced_data(current_data)
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_start$new_data[[i]],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
}
return(unique(new_fits))
}
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  NA #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
append(new_time,c(current_data[,j][1:i]))
} else if (j==2) {
append(new_data,c(current_data[,j][1:i]))
}
}
return(new_start)
}
spliced_data(current_data)
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_start$new_data[[i]],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
}
return(unique(new_fits))
}
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
new_start
new_baar_fit = function(current_data,breakpoints){
new_fits = c() #list of new fitted values
spliced_fitted_arima =  NA #list of arima'ed time series
new_time = c(1) #list of time vectors for each bkpt (for spliced_data)
new_data = c(2) #list of data_45 vectors for each bkpt (for spliced_data)
new_start = data.frame(new_time,new_data)
for (i in breakpoints){
spliced_data = function(current_data){
for (j in 1:ncol(current_data)){
if (j == 1){ #if j is time
append(new_time,c(current_data[,j][1:i]))
} else if (j==2) {
append(new_data,c(current_data[,j][1:i]))
}
}
return(new_start)
}
spliced_data(current_data)
#append to list of arima'ed time series
append(spliced_fitted_arima, arima(new_start$new_data[[i,]],order = c(1,0,0)))
append(new_fits, fitted(spliced_fitted_arima[i]))
}
return(unique(new_fits))
}
#WORK IN PROGRESS ---------------------------------------------------
fits = new_baar_fit(current_data,A3)
