}
}else{ #sigma from penultimate and final runs
final_sigma_list[[i]] = post_sigma_list[,split_num[i-1]:(split_num[i]-1)]
if(is.atomic(final_sigma_list[[i]]) == T){
final_sigma_list[[i]] = as.data.frame(final_sigma_list[[i]])
rownames(final_sigma_list[[i]]) = rownames(post_sigma_list)
colnames(final_sigma_list[[i]]) = 1
}else{
colnames(final_sigma_list[[i]]) = c(1:ncol(final_sigma_list[[i]]))
}
final_sigma_list[[i+1]] = post_sigma_list[,split_num[i]:ncol(post_sigma_list)]
if(is.atomic(final_sigma_list[[i+1]]) == T){
final_sigma_list[[i+1]] = as.data.frame(final_sigma_list[[i+1]])
rownames(final_sigma_list[[i+1]]) = rownames(post_sigma_list)
colnames(final_sigma_list[[i+1]]) = 1
}else{
colnames(final_sigma_list[[i+1]]) = c(1:ncol(final_sigma_list[[i+1]]))
}
}
}
post_sigma_list = final_sigma_list #saving final version of sigma object
}
#getting distribution of k (number of breakpoints)
num_bkpts = list()
for(i in 1:iterations){
current_k = length(all_k_best[i,][!is.na(all_k_best[i,])])
num_bkpts = c(num_bkpts, current_k, recursive=T)
}
if(fit_storage == TRUE){
final_list = list(accept_count / iterations, final.propose, final.accept, all_MSE, all_BIC, all_k_best, num_bkpts, post_beta_list, post_sigma_list, all_fits)
names(final_list) = c("AcceptRate", "ProposedSteps", "AcceptedSteps", "MSE", "BIC", "Breakpoints", "NumBkpts", "Beta", "Sigma", "Fits")
}else{
final_list = list(accept_count / iterations, final.propose, final.accept, all_BIC, all_k_best, num_bkpts)
names(final_list) = c("AcceptRate", "ProposedSteps", "AcceptedSteps", "BIC", "Breakpoints", "NumBkpts")
}
return(final_list)
}
make_murder_p = 0.5
ratio = (-1*delta_bic/2) + (log(q1*dpois(length(k_ends_new)-2,lambda)) - log(q2*dpois(length(k_ends)-2,lambda)))
delta_bic = (-2*new_loglik + log(n)*(length(k_ends_new)-1)*(3+ar)) - (-2*old_loglik + log(n)*(length(k_ends)-1)*(3+ar))
ratios = c(birth_old_to_new_ratio,birth_new_to_old_ratio,death_new_to_old_ratio,death_old_to_new_ratio)
old_new_product_birth = function(product_runs){
for (j in k){
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
}
return(prod(product_runs))
}
product_runs
product_runs = c()
birth_old_to_new_ratio = (factorial(starting_bkpts+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts))
q2 = k_and_q[[3]]
k_and_q = newEnds(k_ends, make_k, murder_k)
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
baar(70,1:90,y,100)
birth_old_to_new_ratio = (factorial(starting_bkpts+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts))
#function to propose a new breakpoint set (also returns qs and step type)
newEnds<-function(k_ends, make_k, murder_k){
u_step = runif(1) #random number from 0 to 1 taken from a uniform distribution for selecting step
if(ar == 1){
constraint = 5
}else{
constraint = ar * 4
}
if(max(diff(k_ends)) >= constraint & length(k_ends) < 3 | max(diff(k_ends)) >= constraint & u_step <= make_k){
type = "add"
a.count <<- a.count + 1
k_ends_new = barMake(k_ends) #make
#setting up qs for ratio
q1 = murder_k/(length(k_ends_new)-2)
n_free = length(freeObservations(k_ends,ar))
q2 = make_k/n_free
} else if(u_step > make_k & u_step <= (make_k + murder_k)){
type = "sub"
s.count <<- s.count + 1
k_ends_new = barMurder(k_ends) #murder
#setting up qs for ratio
n_free = length(freeObservations(k_ends_new,ar))
q1 = make_k/n_free
q2 = murder_k/(length(k_ends)-2)
} else {
move_u = runif(1)
if(move_u < jump_p){
type = "move"
m.count <<- m.count + 1
k_ends_new = barMove(k_ends) #jump
#fake qs because they cancel
q1 = 1
q2 = 1
}else{
type = "jiggle"
j.count <<- j.count + 1
k_ends_new = barJiggle(percent, k_ends) #jiggle
if(k_ends_new[[1]] == "jiggle failure"){
k_ends_new = k_ends
}
#fake qs because they cancel
q1 = 1
q2 = 1
}
}
return(list(k_ends_new, q1, q2, type))
}
k_and_q = newEnds(k_ends, make_k, murder_k)
make_k = make_murder_p * (starting_nfree/starting_ttl) #proportion for make
murder_k = make_murder_p * (starting_bkpts/starting_ttl) #proportion for murder
starting_ttl = starting_bkpts + starting_nfree #total to get percentages
k_and_q = newEnds(k_ends, make_k, murder_k)
#function to randomly add a new breakpoint
barMake<-function(k_ends){
diff_set = freeObservations(k_ends, ar)
if(length(diff_set) < 2){
rand_spot = diff_set
}else{
rand_spot = sample(diff_set, 1) #selects a random spots
}
k_ends_final = sort(c(k_ends, rand_spot)) #adds the random spot and sorts it
return(k_ends_final)
}
k_and_q = newEnds(k_ends, make_k, murder_k)
burn_in = 50, make_murder_p = 0.5, percent = 0.02, lambda = 1, jump_p = 0.25, ar = 1, progress = TRUE, fit_storage = TRUE
burn_in = 50
make_murder_p = 0.5
percent = 0.02
lambda = 1
jump_p = 0.25
ar = 1
k_and_q = newEnds(k_ends, make_k, murder_k)
k_ends_new = k_and_q[[1]]
q1 = k_and_q[[2]]
q2 = k_and_q[[3]]
new_loglik = fitMetrics(k_ends_new, full_data)
old_new_product_birth = function(product_runs){
for (j in k){
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
}
return(prod(product_runs))
}
product_runs = c(1)
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
old_new_product_birth = function(product_runs){
for (j in k){
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
}
return(prod(product_runs))
}
product_death = function(k){
for (j in k){
product_runs = append(product_runs,(n-3*ar-q1*2*ar + j))
}
return(prod(product_runs))
}
birth_old_to_new_ratio = (factorial(starting_bkpts+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts))
k = k_ends[c(-1,-length(k_ends))]
birth_old_to_new_ratio = (factorial(starting_bkpts+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts))
n = length(full_data[,1]) #number of observations
starting_nfree = length(freeObservations(k_ends,ar))
#getting constants for qs for final Metropolis-Hasting
starting_bkpts_2 = length(k_ends) - 1 #most probable number of breakpoints based on starting info
starting_ttl = starting_bkpts_2 + starting_nfree #total to get percentages
make_k = make_murder_p * (starting_nfree/starting_ttl) #proportion for make
murder_k = make_murder_p * (starting_bkpts_2/starting_ttl) #proportion for murder
k_and_q = newEnds(k_ends, make_k, murder_k)
q1 = k_and_q[[2]]
q2 = k_and_q[[3]]
k_ends_new = k_and_q[[1]]
type = k_and_q[[4]]
new_loglik = fitMetrics(k_ends_new, full_data)
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
n = length(full_data[,1]) #number of observations
full_data = cbind(c(1:length(as.numeric(time))), as.numeric(data)) #combining time and data inputs
#full_data = cbind(c(1:length(as.numeric(time))), as.numeric(data)) #combining time and data inputs
full_data = y
n = length(full_data[,1]) #number of observations
full_data = cbind(c(1:length(as.numeric(time))), as.numeric(data)) #combining time and data inputs
n = length(full_data[,1]) #number of observations
full_data = cbind(c(1:length(as.numeric(time))), as.numeric(data)) #combining time and data inputs
k_ends <<- c(min(full_data[,1]), na.omit(k), n) #adding end points to k
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
ratio = (-1*delta_bic/2) + log(birth_old_to_new_ratio) - log(death_new_to_old_ratio)
delta_bic = (-2*new_loglik + log(n)*(length(k_ends_new)-1)*(3+ar)) - (-2*old_loglik + log(n)*(length(k_ends)-1)*(3+ar))
new_loglik = fitMetrics(k_ends_new, full_data)
#function to get sum of log likelihoods
fitMetrics<-function(k_ends, full_data){
#create sum objects
sum_loglik = 0
coef_1 = 0
coef_2 = 0
#get and sum log likelihood for regressions of all intervals
if(length(k_ends) < 3 ){
model = suppressWarnings(FitAR(full_data[,2], p=ar))
SEE = sum(na.omit(model$res)^2)
s2 = SEE/n
sum_loglik = (-1*n/2)*(log(2*pi)+log(s2)+1) #finding the log likeihoods on the full dataset
}else{
for(i in 2:length(k_ends)) {
if(i == 2){
min = k_ends[i-1]
y_values = full_data[c(min:k_ends[i]),2] #getting the y values in the interval
model = suppressWarnings(FitAR(y_values, p=ar))
sub_n = length(y_values)
SEE = sum(na.omit(model$res)^2)
s2 = SEE/sub_n
sub_loglik = (-1*sub_n/2)*(log(2*pi)+log(s2)+1)
sum_loglik = sum_loglik + sub_loglik #the logLik looks the log likelyhood (relates to both SSR and MLE)
}else if(i > 2){
min = k_ends[i-1]
y_values = full_data[c((min+1):k_ends[i]),2] #getting the y values in the interval
model = suppressWarnings(FitAR(y_values, p=ar))
sub_n = length(y_values)
SEE = sum(na.omit(model$res)^2)
s2 = SEE/sub_n
sub_loglik = (-1*sub_n/2)*(log(2*pi)+log(s2)+1)
sum_loglik = sum_loglik + sub_loglik #the logLik looks the log likelihood (relates to both SSR and MLE)
}
}
}
return(sum_loglik)
}
new_loglik = fitMetrics(k_ends_new, full_data)
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
setwd("\\Users\\mellm\\github\\REU2022\\Variations_of_bars")
source("fixedbaar1.R")
install.packages("devtools")
library(devtools)
#Step 3 - set up for simulation
data_fun = test_data_2 #edit here !!! (defines function for generating draws)
#Step 3 - set up for simulation
data_fun = y #edit here !!! (defines function for generating draws)
runs = 3
burn_in = 50
iterations = 250
current_bar = baar
save_name = "KH_check_061222.RData" #edit here !!! (format: "baar_data#.RData")
make = 0.5
percent = 0.02
col_num = 4
lambda = 1
jump = 0.25 #edit here !!!
simulation = function(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump){
#initializing storage for returns from all BAR runs
current_list = list()
current_list[[1]] = list() #AcceptRate
current_list[[2]] = data.frame(matrix(ncol=col_num, nrow=0)) #ProposedSteps
current_list[[3]] = data.frame(matrix(ncol=col_num, nrow=0)) #AcceptedSteps
current_list[[4]] = data.frame(matrix(ncol=0, nrow=iterations)) #MSE
current_list[[5]] = data.frame(matrix(ncol=0, nrow=iterations)) #BIC
current_list[[6]] = data.frame(matrix(ncol=0, nrow=iterations)) #Breakpoints
current_list[[7]] = data.frame(matrix(ncol=0, nrow=iterations)) #NumBkpts
current_list[[8]] = list() #RunTimes
names(current_list) = c("AcceptRate", "ProposedSteps", "AcceptedSteps", "MSE", "BIC", "Breakpoints", "NumBkpts", "RunTimes")
#getting the initial points using the Bai-Perron test
library("strucchange")
#running BAR the specified number of times and storing the results
for(i in 1:runs){
current_data = data_fun()
break_p = breakpoints(current_data[,2] ~ current_data[,1], breaks = 5, h = 0.1)
starting_breakpoints = break_p$breakpoints
start_time = Sys.time()
current_result = current_bar(starting_breakpoints, current_data[,1], current_data[,2], iterations, burn_in, make, percent, lambda, jump)
end_time = Sys.time()
current_list[[1]] = c(current_list[[1]], current_result$AcceptRate[[1]], recursive = TRUE)
current_list[[2]] = rbind(current_list[[2]], current_result$ProposedSteps)
current_list[[3]] = rbind(current_list[[3]], current_result$AcceptedSteps)
current_list[[4]] = cbind(current_list[[4]], current_result$MSE)
current_list[[5]] = cbind(current_list[[5]], current_result$BIC)
current_list[[6]] = cbind(current_list[[6]], current_result$Breakpoints)
current_list[[7]] = cbind(current_list[[7]], current_result$NumBkpts)
current_list[[8]] = c(current_list[[8]], end_time - start_time, recursive = TRUE)
print(i)
}
#returning results of all BAR runs
return(current_list)
}
sim_list = simulation(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump)
split_num = NULL #initializing
colnames(sim_list[[6]]) <- gsub(x = colnames(sim_list[[6]]), pattern = "all_k_best...c..1...ncol.all_k_best...", replacement = "X1")
for(i in 2:ncol(sim_list[[6]])){ #detecting where to split up columns in $Breakpoint object
if(endsWith(colnames(sim_list[[6]])[i], "X1") == TRUE){
split_num = c(split_num, i)
}
}
final_list = list() #initializing
for(i in 1:length(split_num)){ #splitting up columns in $Breakpoint object
if(i == 1){ #breakpoints from first run
final_list[[i]] = sim_list[[6]][,1:(split_num[i]-1)]
}else if(i < length(split_num)){# breakpoints from middle runs
final_list[[i]] = sim_list[[6]][,split_num[i-1]:(split_num[i]-1)]
}else{ #breakpoints from penultimate and final runs
final_list[[i]] = sim_list[[6]][,split_num[i-1]:(split_num[i]-1)]
final_list[[i+1]] = sim_list[[6]][,split_num[i]:ncol(sim_list[[6]])]
}
}
sim_list[[6]] = final_list #saving final version of $Breakpoint object
saveRDS(sim_list, file=save_name)
summary(sim_list)
#sim_list = readRDS() #to load an existing RDS
sim_list = simulation(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump)
source("data_for_trials.R")
setwd("\\Users\\mellm\\github\\REU2022")
source("data_for_trials.R")
#Step 3 - set up for simulation
data_fun = test_data_2 #edit here !!! (defines function for generating draws)
runs = 3
burn_in = 50
iterations = 250
current_bar = baar
save_name = "KH_check_061222.RData" #edit here !!! (format: "baar_data#.RData")
make = 0.5
percent = 0.02
col_num = 4
lambda = 1
jump = 0.25 #edit here !!!
simulation = function(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump){
#initializing storage for returns from all BAR runs
current_list = list()
current_list[[1]] = list() #AcceptRate
current_list[[2]] = data.frame(matrix(ncol=col_num, nrow=0)) #ProposedSteps
current_list[[3]] = data.frame(matrix(ncol=col_num, nrow=0)) #AcceptedSteps
current_list[[4]] = data.frame(matrix(ncol=0, nrow=iterations)) #MSE
current_list[[5]] = data.frame(matrix(ncol=0, nrow=iterations)) #BIC
current_list[[6]] = data.frame(matrix(ncol=0, nrow=iterations)) #Breakpoints
current_list[[7]] = data.frame(matrix(ncol=0, nrow=iterations)) #NumBkpts
current_list[[8]] = list() #RunTimes
names(current_list) = c("AcceptRate", "ProposedSteps", "AcceptedSteps", "MSE", "BIC", "Breakpoints", "NumBkpts", "RunTimes")
#getting the initial points using the Bai-Perron test
library("strucchange")
#running BAR the specified number of times and storing the results
for(i in 1:runs){
current_data = data_fun()
break_p = breakpoints(current_data[,2] ~ current_data[,1], breaks = 5, h = 0.1)
starting_breakpoints = break_p$breakpoints
start_time = Sys.time()
current_result = current_bar(starting_breakpoints, current_data[,1], current_data[,2], iterations, burn_in, make, percent, lambda, jump)
end_time = Sys.time()
current_list[[1]] = c(current_list[[1]], current_result$AcceptRate[[1]], recursive = TRUE)
current_list[[2]] = rbind(current_list[[2]], current_result$ProposedSteps)
current_list[[3]] = rbind(current_list[[3]], current_result$AcceptedSteps)
current_list[[4]] = cbind(current_list[[4]], current_result$MSE)
current_list[[5]] = cbind(current_list[[5]], current_result$BIC)
current_list[[6]] = cbind(current_list[[6]], current_result$Breakpoints)
current_list[[7]] = cbind(current_list[[7]], current_result$NumBkpts)
current_list[[8]] = c(current_list[[8]], end_time - start_time, recursive = TRUE)
print(i)
}
#returning results of all BAR runs
return(current_list)
}
sim_list = simulation(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump)
split_num = NULL #initializing
birth_old_to_new_ratio = (factorial(starting_bkpts_2+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts_2))
birth_old_to_new_ratio = (factorial(starting_bkpts_2+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts_2))
n = 30
birth_old_to_new_ratio = (factorial(starting_bkpts_2+1)*q2*(dpois(k_ends_new,lambda)))/(old_new_product_birth(starting_bkpts_2))
starting_bkpts_2+1
q2
(dpois(k_ends_new,lambda))
k_ends_new
birth_old_to_new_ratio = (factorial(starting_bkpts+1)*q2*(dpois(length(k_ends_new)-2,lambda)))/(old_new_product_birth(starting_bkpts))
birth_new_to_old_ratio = (factorial(starting_bkpts)*q1*(dpois(length(k_ends)-2,lambda)))/(product_death(starting_bkpts))
death_new_to_old_ratio = (factorial(starting_bkpts)*q2*(dpois(length(k_ends)-2,lambda)))/(product_death(starting_bkpts))
death_old_to_new_ratio = (factorial(starting_bkpts-1)*make_k*(dpois(length(k_ends_new)-2,lambda)))/(old_new_product_death(starting_bkpts))
product_runs = append(product_runs,(n-3*ar-(q1-1)*(2*ar)+j))
old_new_product_death = function(k){
for (j in k){
product_runs = append(product_runs,(n-3*ar-(q1-1)*(2*ar)+j))
}
return(prod(product_runs))
}
death_old_to_new_ratio = (factorial(starting_bkpts-1)*make_k*(dpois(length(k_ends_new)-2,lambda)))/(old_new_product_death(starting_bkpts))
ratios = c(birth_old_to_new_ratio,birth_new_to_old_ratio,death_new_to_old_ratio,death_old_to_new_ratio)
prior[i] = 1-ratios[i]
delta_bic = (-2*new_loglik + log(n)*(length(k_ends_new)-1)*(3+ar)) - (-2*old_loglik + log(n)*(length(k_ends)-1)*(3+ar))
ratio = (-1*delta_bic/2) + log(birth_old_to_new_ratio) - log(death_new_to_old_ratio)
new_loglik = fitMetrics(k_ends_new, full_data)
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
baar(69,1:90,y,100)
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
old_new_product_birth = function(product_runs){
for (j in k){
product_runs = append(product_runs,(n-(3*ar-(q1+1)*(2*ar + j))))
}
return(prod(product_runs))
}
product_death = function(k){
for (j in k){
product_runs = append(product_runs,(n-3*ar-q1*2*ar + j))
}
return(prod(product_runs))
}
old_new_product_death = function(k){
for (j in k){
product_runs = append(product_runs,(n-3*ar-(q1-1)*(2*ar)+j))
}
return(prod(product_runs))
}
n = 30
prior = c()
birth_old_to_new_ratio = (factorial(starting_bkpts_2+1)*q2*(dpois(length(k_ends_new)-2,lambda)))/(old_new_product_birth(starting_bkpts_2))
birth_new_to_old_ratio = (factorial(starting_bkpts_2)*q1*(dpois(length(k_ends)-2,lambda)))/(product_death(starting_bkpts_2))
death_new_to_old_ratio = (factorial(starting_bkpts_2)*q2*(dpois(length(k_ends)-2,lambda)))/(product_death(starting_bkpts_2))
death_old_to_new_ratio = (factorial(starting_bkpts_2-1)*make_k*(dpois(length(k_ends_new)-2,lambda)))/(old_new_product_death(starting_bkpts_2))
ratios = c(birth_old_to_new_ratio,birth_new_to_old_ratio,death_new_to_old_ratio,death_old_to_new_ratio)
for (i in ratios){ #finds priors for birth and death ratios
prior[i] = 1-ratios[i]
}
#end of birth and death ratios
delta_bic = (-2*new_loglik + log(n)*(length(k_ends_new)-1)*(3+ar)) - (-2*old_loglik + log(n)*(length(k_ends)-1)*(3+ar))
ratio = (-1*delta_bic/2) + (log(q1*dpois(length(k_ends_new)-2,lambda)) - log(q2*dpois(length(k_ends)-2,lambda)))
u_ratio = log(runif(1)) #random number from 0 to 1 taken from a uniform distribution and then log transformed
log(q1*dpois(length(k_ends_new)-2,lambda)
(log(q1*dpois(length(k_ends_new)-2,lambda)) - log(q2*dpois(length(k_ends)-2,lambda)))
ratio = (-1*delta_bic/2) + (log(q1*dpois(length(k_ends_new)-2,lambda)) - log(q2*dpois(length(k_ends)-2,lambda)))
beta=-1
y=rnorm(1,0,1)
for(i in 2:32){y[i]=beta*y[i-1]+rnorm(1,0,1)}
for(i in 33:90){y[i]=beta*y[i-1]+rnorm(1,0,3)}
baar(100,1:92,y,100)
baar(100,1:90,y,100)
baar(100,1:90,y,100)
baar(10,1:90,y,100)
baar(100,1:90,y,100)
baar(50,1:90,y,100)
install.packages("devtools")
install.packages("devtools")
library(devtools)
install_version("FitAR", version = "1.94", repos = "http://cran.us.r-project.org")
library(FitAR)
setwd("\\Users\\mellm\\github\\REU2022\\Variations_of_bars")
source("fixedbaar1.R")
setwd("\\Users\\mellm\\github\\REU2022")
source("data_for_trials.R")
#Step 3 - set up for simulation
data_fun = test_data_2 #edit here !!! (defines function for generating draws)
runs = 3
burn_in = 50
iterations = 250
current_bar = baar
save_name = "KH_check_061222.RData" #edit here !!! (format: "baar_data#.RData")
make = 0.5
percent = 0.02
col_num = 4
lambda = 1
jump = 0.25 #edit here !!!
simulation = function(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump){
#initializing storage for returns from all BAR runs
current_list = list()
current_list[[1]] = list() #AcceptRate
current_list[[2]] = data.frame(matrix(ncol=col_num, nrow=0)) #ProposedSteps
current_list[[3]] = data.frame(matrix(ncol=col_num, nrow=0)) #AcceptedSteps
current_list[[4]] = data.frame(matrix(ncol=0, nrow=iterations)) #MSE
current_list[[5]] = data.frame(matrix(ncol=0, nrow=iterations)) #BIC
current_list[[6]] = data.frame(matrix(ncol=0, nrow=iterations)) #Breakpoints
current_list[[7]] = data.frame(matrix(ncol=0, nrow=iterations)) #NumBkpts
current_list[[8]] = list() #RunTimes
names(current_list) = c("AcceptRate", "ProposedSteps", "AcceptedSteps", "MSE", "BIC", "Breakpoints", "NumBkpts", "RunTimes")
#getting the initial points using the Bai-Perron test
library("strucchange")
#running BAR the specified number of times and storing the results
for(i in 1:runs){
current_data = data_fun()
break_p = breakpoints(current_data[,2] ~ current_data[,1], breaks = 5, h = 0.1)
starting_breakpoints = break_p$breakpoints
start_time = Sys.time()
current_result = current_bar(starting_breakpoints, current_data[,1], current_data[,2], iterations, burn_in, make, percent, lambda, jump)
end_time = Sys.time()
current_list[[1]] = c(current_list[[1]], current_result$AcceptRate[[1]], recursive = TRUE)
current_list[[2]] = rbind(current_list[[2]], current_result$ProposedSteps)
current_list[[3]] = rbind(current_list[[3]], current_result$AcceptedSteps)
current_list[[4]] = cbind(current_list[[4]], current_result$MSE)
current_list[[5]] = cbind(current_list[[5]], current_result$BIC)
current_list[[6]] = cbind(current_list[[6]], current_result$Breakpoints)
current_list[[7]] = cbind(current_list[[7]], current_result$NumBkpts)
current_list[[8]] = c(current_list[[8]], end_time - start_time, recursive = TRUE)
print(i)
}
#returning results of all BAR runs
return(current_list)
}
sim_list = simulation(data_fun, runs, iterations, burn_in, current_bar, make, percent, lambda, jump)
split_num = NULL #initializing
colnames(sim_list[[6]]) <- gsub(x = colnames(sim_list[[6]]), pattern = "all_k_best...c..1...ncol.all_k_best...", replacement = "X1")
for(i in 2:ncol(sim_list[[6]])){ #detecting where to split up columns in $Breakpoint object
if(endsWith(colnames(sim_list[[6]])[i], "X1") == TRUE){
split_num = c(split_num, i)
}
}
final_list = list() #initializing
for(i in 1:length(split_num)){ #splitting up columns in $Breakpoint object
if(i == 1){ #breakpoints from first run
final_list[[i]] = sim_list[[6]][,1:(split_num[i]-1)]
}else if(i < length(split_num)){# breakpoints from middle runs
final_list[[i]] = sim_list[[6]][,split_num[i-1]:(split_num[i]-1)]
}else{ #breakpoints from penultimate and final runs
final_list[[i]] = sim_list[[6]][,split_num[i-1]:(split_num[i]-1)]
final_list[[i+1]] = sim_list[[6]][,split_num[i]:ncol(sim_list[[6]])]
}
}
sim_list[[6]] = final_list #saving final version of $Breakpoint object
saveRDS(sim_list, file=save_name)
summary(sim_list)
#sim_list = readRDS() #to load an existing RDS
#sim_list = readRDS() #to load an existing RDS
source("C:/Users/mellm/github/REU2022/baar_simulations.R")
